# Stack Tower 開発ログ v1.2 ～ v1.3.6

## 🎮 概要

Stack Tower は、物理演算エンジン Pymunk を用いたブロック積みゲームである。ランダム形状・角度のブロックを制限時間内にどれだけ高く積めるかを競う。

本バージョンログでは、v1.2 から v1.3.6 までの開発・改良内容を記録する。

---

## ✅ v1.2.0 - ベースの完成

* KINEMATIC 状態でブロックを生成 → DOWNキーまたは自動で落下 → DYNAMIC に変換
* スコアは単純加点（ブロック種別に応じた定数倍率）
* タイム制限はなし

---

## ✅ v1.3.0 - タイム制導入

* `GAME_DURATION_MS = 30秒` に設定
* `Time Left: Xs` を画面左上に表示
* タイム終了後に `GAME OVER` 表示
* ゲーム操作を無効化

---

## ✅ v1.3.1 - リアルタイムスコアへ移行

* ブロックの落下時加点を廃止
* 代わりに、毎フレーム `calculate_score()` により積み上げ高さを算出
* 「現在スコア = 接地ブロックの高さ」へシフト

---

## ✅ v1.3.2 - 接地ブロックのみに限定

* 落下中ブロックがスコアに影響する問題を修正
* 接地済み判定（`abs(v_y) < 1.0`）を導入
* 接地したブロックは `settled_blocks` に追加
* スコア計算は `settled_blocks` のみに限定

---

## ✅ v1.3.3 - 視覚演出の強化

* ゲーム終了後に `Finished!` 表示
* その下に `Final Score: xxx`
* 最も高いブロックの **角の位置** を検出し、赤線を描画

---

## ✅ v1.3.4 - 赤線位置の精密化

* ブロックの「body.position.y」ではなく、`最上部の角（最小y）` を検出して赤線に反映

---

## ✅ v1.3.5 - 見た目の床追加

* 見た目の床：`pygame.draw.rect(screen, (100, 100, 100), ...)`
* 物理的な床の当たり判定：Segment を `HEIGHT - 5` に下げて調整
* セグメントの太さを `10` に拡張して貫通を防止

---

## 💡 プレイヤーとしての気づき・体感

* （補足）このゲームをそのまま強化学習で扱おうとすると、状態空間の複雑さ（ブロックの位置・角度・速度）、行動の時間依存性、報酬の遅延性など、初学者にはハードルが高いと感じた。

* 強化学習に活かすには、前段階としてもっとシンプルな環境を用意し、行動・報酬設計の練習をした方が良いという気づきも得られた。

* 見た目がきちんとしていないと、ゲームとしての没入感が損なわれる（床の浮きなど）

* スコアがリアルタイムで上下すると混乱する → 接地したものだけで評価されると納得感が高まる

* 高く積めたと思ってもスコアが低いことがあり、\*\*「高さの定義」\*\*がとても重要だと実感

* 難易度が高く、真剣にやっても全く積めないことがある → ランダム性・操作性・戦略性がちょうど良く混ざっていて奥深い

* 自動落下と手動落下を併用できるのが良く、「落とすタイミング」も戦略の一部になっている

## 🎯 現在の完成度（v1.3.6）

* タイム制・落下自動／手動両対応
* ランダムな形・角度・サイズのブロック生成
* スコアは接地ブロックの最上端から算出
* ゲーム終了後の見た目演出（`Finished!`, Final Score, 赤線）
* ブロック・床の見た目整合性確保

---

## 🧩 今後の発展案

* スペースキーでリスタート
* スコア履歴保存 / CSVログ
* サウンド効果
* 強化学習ログ出力 / gym.Env 化
* StackTower前段階のミニRL環境設計（予定）

</br>
</br>
</br>
</br>
</br>


# 📘 LEARNED.md v1.1 — Stack Tower 開発ログ（押しっぱなし対応・自前描画）

このバージョンでは、ユーザー操作・描画制御・物理設計の基礎を整理し、以下の3つを軸に改善を加えた。

---

## ✅ 追加・改善された機能

### 1. 🎮 押しっぱなしでブロックを移動できるようにした

* `pygame.KEYDOWN` は「押した瞬間」しか検出しないため、
* 毎フレーム状態を確認できる `pygame.key.get_pressed()` に切り替えた。
* これによりスムーズな横移動が可能になり、操作性が格段に向上した。

### 2. 🎨 ブロック描画を `debug_draw` から `自前描画` に変更

* 目的：色の統一・制御、および UI 表示との整合性。
* `pymunk.Poly.get_vertices()` + `pygame.draw.polygon()` により自由な見た目制御が可能に。
* 操作中ブロック（KINEMATIC）と落下後ブロック（DYNAMIC）で色分け：

  * 緑：操作中ブロック
  * 青：落下済みブロック

### 3. ⏱️ ブロック出現に 0.5 秒の遅延を導入

* 落下直後に次のブロックが現れると衝突して不自然になる。
* `scheduled_create_time` を使って時間経過後に新ブロックを生成することで、

  * ゲームテンポを維持しつつ
  * ビジュアル的にも自然な切り替えが実現。

---

## 🧠 学び・技術ポイント

### ✅ `pygame.key.get_pressed()` の性質

* イベントではなく「状態」ベースで取得する入力管理方式。
* 毎フレーム呼び出してもOK（内部でキャッシュ済）
* 押しっぱなしの操作や連続移動、連打によるリピートにも強い。

### ✅ `debug_draw()` の限界と自前描画の利点

* `debug_draw()`：開発初期には便利だが、色・順序・UI混在に対応できない。
* 自前描画のメリット：

  * 色やスタイルを自由に決定
  * 表示順序を制御可能（UI/エフェクトとの重ね順）
  * 今後のアニメーション導入にも対応しやすい

### ✅ `KINEMATIC` → `DYNAMIC` の切り替えは避けるべし

* pymunkでは物理状態の途中変更に弱く、NaNエラーが発生する。
* 安定策として `KINEMATIC` block を一度削除し、`DYNAMIC` block を新規に作成する方式を採用。

---

## 🔧 その他設定・変更

* `MOVE_STEP = 5`：ブロックの横移動の粒度を調整（細かくて心地よい）
* `DROP_INTERVAL_MS = 3000`：落下間隔を3秒に調整
* `NEW_BLOCK_DELAY_MS = 500`：次のブロック出現までの待機時間を設定

---

## 🚀 次の展開候補

* ゲームオーバー判定（転倒・画面上限）
* スコア機能（積み上げ高さ）
* サウンド・エフェクト導入
* 強化学習に向けた状態/行動空間の定義とエピソード管理

---

> 🎉 version 1.1 は「直感的に操作でき、見た目も整った」初のプレイアブルな形となった。ここからはゲーム性・フィードバック性の強化に進んでいく。

</br>
</br>
</br>
</br>
</br>


# 📘 LEARNED.md — Stack Tower 開発ログと学習メモ

このドキュメントは、`stacktower-py` の開発を進める中で得た知見や理解を時系列・構造的にまとめたものです。

---

## ✅ Initialization & Display（初期化と画面表示）

* `pygame.init()` は各種モジュール（表示・音声など）をまとめて初期化する。忘れると `pygame.error: video system not initialized` が起こる可能性がある。
* `pygame.display.set_mode()` はウィンドウサイズやフラグを指定できる。例えば `RESIZABLE`（サイズ変更可）、`FULLSCREEN`、`NOFRAME`（枠なし）などがある。
* `pygame.time.Clock()` によってフレームレート管理が可能となり、`clock.tick(FPS)` で 1 秒あたりの最大フレーム数を制限できる。

---

## ✅ Space and Gravity（物理空間と重力）

* `pymunk.Space()` は物理世界を表す中心オブジェクト。
* `space.gravity = (0, 900)` によって y 軸下方向に加速度がかかる（単位は pixel/s^2）。
* `space.step(dt)` によって世界が dt 秒だけ進行する。

---

## ✅ Static vs Dynamic Bodies（固定物体と可動物体）

* **地面**は `pymunk.Segment(...)` を `space.static_body` に紐づけて作成。動かず、摩擦や衝突の判定には使われる。
* **ブロック**は `pymunk.Body(mass, moment)` で生成され、質量と回転しやすさ（moment）を持つ。
* `space.add()` によって Space に存在させなければ動作しない。

---

## ✅ Shapes and Positioning（形状と位置指定）

* ブロックの形状には `pymunk.Poly.create_box(...)` を使用。これは `Poly` のショートカットで、中心を原点にした矩形を生成する。
* `body.position = (x, y)` によって物体の重心位置が決まる。
* `Segment`, `Circle`, 任意の `Poly` など、他の形状も存在する。

---

## ✅ Game Loop（ゲームループ）

```python
while running:
    pygame.event.get()     # 入力イベント処理
    screen.fill(...)       # 背景をリセット
    space.step(1/FPS)      # 物理演算を1フレーム進行
    space.debug_draw(...)  # pymunkによる描画
    pygame.display.flip()  # 表示の更新
    clock.tick(FPS)        # フレームレートの調整
```

* `screen.fill()` は前フレームの残像を消すために必要。
* `space.step()` の dt と `clock.tick(FPS)` の FPS を一致させることで、安定した挙動が得られる。
* `flip()` は画面全体を更新し、`tick()` によって無限ループの暴走を防ぐ。

---

## ✅ 時間ステップ設計と物理安定性

* 固定ステップ（`dt = 1 / FPS`）は再現性・安定性があり、教育・強化学習にも向いている。
* 可変ステップ（`dt = clock.tick(...) / 1000`）は実時間ベースで柔軟だが、不安定になりやすく、再現性が低下する。
* `pymunk` の推奨は「固定ステップ + 安定フレームレート」である。

---

## ✅ その他補足

* `debug_draw()` は物理世界の可視化に便利だが、見た目のカスタマイズには不向き。
* UI（スコアやボタンなど）は別レイヤーで描画すれば問題なし。
* 慣れてきたら `debug_draw` をやめて、自前で `pygame.draw.rect()` などを使って描画する方向に進むと良い。

---

> 📌 まとめ：**「Body（状態） + Shape（形） + Space（世界）」で構成される物理世界**を、clock と loop で回していくという設計が pymunk の基本構造。
